# acwing打卡记录

## 3.5

快排+归并排序

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
using namespace std;
//归并排序
void merge(int p[],int l,int r){
    if(l>=r) return;
    int mid = l+r>>1;
    merge(p,l,mid),merge(p,mid+1,r);
    int *temp =new int[r-l];
    int i=l,j=mid+1;
    int k=0;
    while(i<=mid && j<=r){
        if(p[i]<p[j]) temp[k++]=p[i++];
        else temp[k++]=p[j++];
    }
    while(i<=mid) temp[k++]=p[i++];
    while(j<=r) temp[k++]=p[j++];
    for (int i=l,k=0;i<=r;i++,k++){
        p[i]=temp[k];
    }
    delete [] temp;
}

int main(){
    int p[]={1,5,3,5,6,2};
    merge(p,0,5);
    for(int i=0;i<6;i++){
        cout<<p[i]<<' ';
    }
    cout<<endl;
}

```



二分法

二分法只适用于已经排好序的数组

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
using namespace std;
//二分
//应用场景：在有序数组中查找特定元素位置
void merge(int p[],int l,int r){
    if(l>=r) return;
    int mid = l+r>>1;
    merge(p,l,mid),merge(p,mid+1,r);
    int *temp =new int[r-l];
    int i=l,j=mid+1;
    int k=0;
    while(i<=mid && j<=r){
        if(p[i]<p[j]) temp[k++]=p[i++];
        else temp[k++]=p[j++];
    }
    while(i<=mid) temp[k++]=p[i++];
    while(j<=r) temp[k++]=p[j++];
    for (int i=l,k=0;i<=r;i++,k++){
        p[i]=temp[k];
    }
    delete [] temp;
}
int main(){
    int p[]={4,3,6,1,7,4,7,9};
    merge(p,0,7);
    int l=0,r=7,x=4;
    //模板1 找第一个
//    while(l<r){
//        int mid=l+r>>1; //mid向l靠
//        if(p[mid]>=x){
//            r=mid;
//        }
//        else l=mid+1;
//    }

    //模板2 找最后一个
    while(l<r){
        int mid=l+r+1>>1; //mid向r靠
        if(p[mid]<=x) l=mid;
        else r=mid-1;
    }
    if(p[r]!=x){
        cout<<"无"<<endl;
    }
    else{
        cout<<r<<endl;
    }

}

```

795 前缀和

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
using namespace std;
//前缀和
//使用另一个数组存储前n个数的和
//递归求解 s[i+1]=s[i]+a[i]
//应用场景，求某段数的和
//一维

const int N = 100000;
int main(){
    int n,m;
    cin>>n>>m;
    int a[n],s[n];
    s[0] = 0;
    for(int i=0;i<n;i++){
        cin>>a[i];
        s[i+1]=s[i]+a[i];
    }
    
    while(m--){
        int l,r;
        cin>>l>>r;
        cout<<s[r]-s[l-1]<<endl;
    }
}

```

797 差分

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
using namespace std;
//差分
//应用场景 给数组中某一段加上固定值
//核心思想：将a作为b的前缀和，b[i]+c相当于a[i]及之后的所有数都+c
int main(){
    int n,m;
    cin>>n>>m;
    int a[n+1],b[n+1];
    a[0]=0;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        b[i]=a[i]-a[i-1];
    }
    while(m--){
        int l,r,c;
        cin>>l>>r>>c;
        b[l]+=c;
        b[r+1]-=c;
    }
    for(int i=2;i<=n;i++){
        b[i]+=b[i-1];
    }
    for(int i=1;i<=n;i++){
        cout<<b[i]<<' ';
    }
}

```





# leetcode hot100

## 哈希表

### 128 最长连续序列

>   自己的思路，用set的

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        set<int> all;
        int max =0;
        for(int & num : nums){
            all.insert(num);
        }
        for(auto it = nums.begin();it!=nums.end();it++){
            int temp = 1;
            int n = *it+1;
            while(all.find(n)!=all.end()) {
                temp+=1;
                n++;
                it++;
            }
            if(max<temp){
                max = temp;
            }
        }
        return max;
    }
};
```

 官方题解：

差别，如果对当前num，存在num-1，跳过，因为上一步已经遍历过了

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> num_set;
        for (const int& num : nums) {
            num_set.insert(num);
        }

        int longestStreak = 0;

        for (const int& num : num_set) {
            if (!num_set.count(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;

                while (num_set.count(currentNum + 1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }

                longestStreak = max(longestStreak, currentStreak);
            }
        }

        return longestStreak;           
    }
};

```

## 滑动窗口

### 209 [长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

自己方法：前缀和加双指针

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
#include <vector>
#include <string>
#include <set>
using namespace std;

class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        //先写前缀和
        int s[nums.size()+1];
        s[0]=0;
        for(int i=0;i<nums.size();i++){
            s[i+1]=s[i]+nums[i];
        }
        //双指针
        int l=0,r=0;
        int min=nums.size();
        while(r<nums.size()){
            while(s[r]-s[l]<target && r<nums.size()) r++;
            while(s[r]-s[l]>target && r<nums.size()) l++;
            if(min>r-l && s[r]-s[l]==target) {
                min=r-l;
                r++;
            }
        }
        while(l<nums.size() && s[r]-s[l]>target){
            l++;
        }
        if(min>r-l && s[r]-s[l]==target) min=r-l;
        return min;
    }
};

int main(){
   int target =7;
   vector <int> nums;
   int a[]={2,3,1,2,4,3};
   nums.insert(nums.begin(),a,a+6);
   Solution s;
   int min;
   min=s.minSubArrayLen(target,nums);
   cout<<min<<endl;
}
```

题解：

```
'''
    滑动窗口
    l和r左右指针维护一个窗口，初始时均指向0, s=0代表[l, r]这个窗口的和
    while r < len(nums):
        # 求和
        s += nums[r]
        # while s >= target, 更新答案，且缩小窗口，即s-=nums[l], l+=1
        扩充窗口，即r+=1

    返回最终答案
    时间复杂度O(n), n=len(nums)
    空间复杂度O(1), 若干中间变量
    '''
```

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int m = nums.size();
        int i = 0, sum = 0, res = INT_MAX;
        for(int j = 0; j < m; j++){
            sum += nums[j];
            while(sum >= target){
                res = min(j - i + 1, res);
                sum -= nums[i];
                i++;
            }
        }
        return res < INT_MAX ? res : 0;
    }
};
```

### 3.无重复字符的最长子串

==有边界问题==

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
#include <vector>
#include <string>
#include <set>
using namespace std;

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int e[26]={0}; //用来存放当前窗口中存在的字符
        int res = 0; //最终结果
        int l=0,r=0; //左右指针，窗口的两边
        //如果当前窗口中没有重复的字符，r++，else，l++
        if(!s.length()) return 0;
        while(r<s.length()){
            if(s[r]-'a'>26 || s[r]-'a'<0){
                r++;
                res = max(res, r - l);
            }
            else {
                while (e[int(s[r] - 'a')] && l < r) {
                    res = max(res, r - l);
                    l++;
                }
                e[int(s[r] - 'a')] = 1;
                r++;
            }
        }

        return res;
    }
};

int main(){
    string a=" ";
    Solution s;
    cout<<s.lengthOfLongestSubstring(a)<<endl;
}
```

正确答案：

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        set<char> lookup;
        int l=0,r=0;
        int res=0;
        while(r<s.length()){
            while(lookup.find(s[r])!=lookup.end()){
                lookup.erase(s[l]);
                l++;
            }
            res = max(res,r-l+1);
            lookup.insert(s[r]);
            r++;
        }
        return res;
    }
};
```

###[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
#include <vector>
#include <string>
#include <set>
#include <unordered_set>
#include <array>
using namespace std;

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> res;
        array <int,26> cnt_p{};
        array<int, 26> cnt_s{};;
        for(char s:p){
            cnt_p[s-'a']+=1;
        }
        int l=0;
        for(int r=0;r<s.length();r++){
            cnt_s[s[r]-'a']+=1; //右端进入窗口
            if(r<p.length()-1) continue;
            if(cnt_p==cnt_s){
                res.push_back(r-p.length()+1);
            }
            cnt_s[s[r-p.length()+1]-'a']--;
        }
        return res;
    }
};

int main(){
    string s="cbaebabacd";
    string p="abc";
    Solution f;
    f.findAnagrams(s,p);
    
}
```

方法二，动态窗口，静态窗口是使两个数组相同，动态窗口是使最终的长度相同时两字符串相同

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> ans;
        int cnt[26]{}; // 统计 p 的每种字母的出现次数
        for (char c : p) {
            cnt[c - 'a']++;
        }
        int left = 0;
        for (int right = 0; right < s.size(); right++) {
            int c = s[right] - 'a';
            cnt[c]--; // 右端点字母进入窗口
            while (cnt[c] < 0) { // 字母 c 太多了
                cnt[s[left] - 'a']++; // 左端点字母离开窗口
                left++; 
            }
            if (right - left + 1 == p.length()) { // s' 和 p 的每种字母的出现次数都相同
                ans.push_back(left); // s' 左端点下标加入答案
            }
        }
        return ans;
    }
};

作者：灵茶山艾府
链接：https://leetcode.cn/problems/find-all-anagrams-in-a-string/solutions/2969498/liang-chong-fang-fa-ding-chang-hua-chuan-14pd/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



##子串

### [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

有坑，子数组并不是全为正数，所以不能使用双指针，需要使用哈希表进行优化

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
#include <vector>
#include <string>
#include <set>
#include <unordered_set>
#include <array>
#include <unordered_map>
using namespace std;
//前缀和加双指针
//有负数，双指针不行，因为前缀和不是递增的
//用哈希表优化，记录前缀和的值和出现的次数
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int s[nums.size()+1];
        s[0] = 0;
        int res;
        for(int i=0;i<nums.size();i++){
            s[i+1] = s[i] + nums[i];
        }
        unordered_map<int,int> map; //key是前缀和值，通过count计算前缀和出现的次数
        for(int a:s){
            //这里一边插入一边查找，可以只找用于找到左侧已经存在的前缀和，避免重复
            res+=map.count(a-k);
            map.insert(make_pair(a,1));
        }
        return res;
    }
};


int main(){
    int a[3]={1,1,1};
    vector<int> nums;
    nums.insert(nums.begin(),a,a+3);
    Solution s;
    cout<<s.subarraySum(nums,2);
}
```



##普通数组

### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

前缀和解，有问题，只适用最小值在最大值左侧的情况

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if(nums.size()==1){
            return nums[0];
        }
        int s[nums.size()+1];
        s[0] = 0;
        int max = -10000;
        int min = 10000;
        for(int i=0;i<nums.size();i++){
            s[i+1] = s[i] + nums[i];
            if(s[i+1]>max) max = s[i+1];
            if(s[i+1]<min) min = s[i+1];
        }
        if(min>=0) return max;
        else return max-min;
    }
};
```

标准题解：

动态规划解法

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int pre = 0; //前一个值的最大连续子数组和,从0开始
        int res = nums[0]; //整体最大值，随机初始
        for(int n:nums){
            pre = max(n,pre+n);
            res = max(pre,res);
        }
        return res;
    }
};

```

前缀和方法，想的不同，这里维护的是当前前缀和的最小值，而不是全局最小值

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int ans = INT_MIN;
        int min_pre_sum = 0;
        int pre_sum = 0;
        for (int x : nums) {
            pre_sum += x; // 当前的前缀和
            ans = max(ans, pre_sum - min_pre_sum); // 减去前缀和的最小值
            min_pre_sum = min(min_pre_sum, pre_sum); // 维护前缀和的最小值
        }
        return ans;
    }
};

作者：灵茶山艾府
链接：https://leetcode.cn/problems/maximum-subarray/solutions/2533977/qian-zhui-he-zuo-fa-ben-zhi-shi-mai-mai-abu71/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
    
    
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int s[nums.size()+1];
        int presum=0,minpresum=0;//presum 当前前缀和，minpresum 当前前缀和之前的最小值
        int ans=nums[0];
        for(int i=0;i<nums.size();i++){
            presum+=nums[i];
            ans = max(ans,presum-minpresum);
            minpresum = min(presum,minpresum);
        }
        return ans;
    }
};
```

### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

如果能在答案上直接操作就直接操作，不要中间商赚差价，会有边界问题

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
#include <vector>
#include <string>
#include <set>
#include <unordered_set>
#include <array>
#include<map>
#include <unordered_map>
using namespace std;
//对于二维向量的排序，sort默认为按第一列升序，如果需要自定义排序，可以用仿函数重载()运算符
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if(intervals.empty()) return{};
        sort(intervals.begin(),intervals.end());
        vector<vector<int>> res;
        int l=-1,r=0;
        res.push_back(intervals[0]);
        //这里的边界条件有点东西，当超出范围，直接将下一个压入res中，如果后面还有就继续判断，没有就返回
        for(int i=0;i<intervals.size();i++){
            if(intervals[i][0]<=res[res.size()-1][1]) res[res.size()-1][1]=max(res[res.size()-1][1],intervals[i][1]);
            else{
                res.push_back(intervals[i]);
            }
        }
        return res;
    }
};


int main(){
    vector<vector<int>> intervals;
    intervals.push_back({1,3});
    intervals.push_back({2,6});
    intervals.push_back({8,10});
    intervals.push_back({15,18});

    Solution s;
    s.merge(intervals);
}
```





### [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

超时了，注意insert的使用

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        for(int i=0;i<k;i++){
            int temp = nums.back();
            nums.pop_back();
            //在vector头部insert的时间复杂度是O(n)的，因为会使所有元素后移一位
            nums.insert(nums.begin(),temp);
        }
    }
};

```

题解：

空间换时间

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> newArr(n);
        for (int i = 0; i < n; ++i) {
            newArr[(i + k) % n] = nums[i];
        }
        nums.assign(newArr.begin(), newArr.end());
    }
};

```



### [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

前缀积&后缀积

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int front_mul[nums.size()+1];
        int back_mul[nums.size()+1];
        front_mul[0]=1;
        back_mul[0]=1;
        vector<int> res;
        for(int i=0;i<nums.size();i++){
            front_mul[i+1] = front_mul[i]*nums[i];
            res.push_back(front_mul[i]);
        }
        for(int i=nums.size();i>0;i--){
            back_mul[nums.size()-i+1] = back_mul[nums.size()-i] * nums[i-1];
            res[i-1]*=back_mul[nums.size()-i];
        }
        return res;
    }
};
```

