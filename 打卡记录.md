# acwing打卡记录

## 3.5

快排+归并排序

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
using namespace std;
//归并排序
void merge(int p[],int l,int r){
    if(l>=r) return;
    int mid = l+r>>1;
    merge(p,l,mid),merge(p,mid+1,r);
    int *temp =new int[r-l];
    int i=l,j=mid+1;
    int k=0;
    while(i<=mid && j<=r){
        if(p[i]<p[j]) temp[k++]=p[i++];
        else temp[k++]=p[j++];
    }
    while(i<=mid) temp[k++]=p[i++];
    while(j<=r) temp[k++]=p[j++];
    for (int i=l,k=0;i<=r;i++,k++){
        p[i]=temp[k];
    }
    delete [] temp;
}

int main(){
    int p[]={1,5,3,5,6,2};
    merge(p,0,5);
    for(int i=0;i<6;i++){
        cout<<p[i]<<' ';
    }
    cout<<endl;
}

```



二分法

二分法只适用于已经排好序的数组

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
using namespace std;
//二分
//应用场景：在有序数组中查找特定元素位置
void merge(int p[],int l,int r){
    if(l>=r) return;
    int mid = l+r>>1;
    merge(p,l,mid),merge(p,mid+1,r);
    int *temp =new int[r-l];
    int i=l,j=mid+1;
    int k=0;
    while(i<=mid && j<=r){
        if(p[i]<p[j]) temp[k++]=p[i++];
        else temp[k++]=p[j++];
    }
    while(i<=mid) temp[k++]=p[i++];
    while(j<=r) temp[k++]=p[j++];
    for (int i=l,k=0;i<=r;i++,k++){
        p[i]=temp[k];
    }
    delete [] temp;
}
int main(){
    int p[]={4,3,6,1,7,4,7,9};
    merge(p,0,7);
    int l=0,r=7,x=4;
    //模板1 找第一个
//    while(l<r){
//        int mid=l+r>>1; //mid向l靠
//        if(p[mid]>=x){
//            r=mid;
//        }
//        else l=mid+1;
//    }

    //模板2 找最后一个
    while(l<r){
        int mid=l+r+1>>1; //mid向r靠
        if(p[mid]<=x) l=mid;
        else r=mid-1;
    }
    if(p[r]!=x){
        cout<<"无"<<endl;
    }
    else{
        cout<<r<<endl;
    }

}

```

795 前缀和

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
using namespace std;
//前缀和
//使用另一个数组存储前n个数的和
//递归求解 s[i+1]=s[i]+a[i]
//应用场景，求某段数的和
//一维

const int N = 100000;
int main(){
    int n,m;
    cin>>n>>m;
    int a[n],s[n];
    s[0] = 0;
    for(int i=0;i<n;i++){
        cin>>a[i];
        s[i+1]=s[i]+a[i];
    }
    
    while(m--){
        int l,r;
        cin>>l>>r;
        cout<<s[r]-s[l-1]<<endl;
    }
}

```

797 差分

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
using namespace std;
//差分
//应用场景 给数组中某一段加上固定值
//核心思想：将a作为b的前缀和，b[i]+c相当于a[i]及之后的所有数都+c
int main(){
    int n,m;
    cin>>n>>m;
    int a[n+1],b[n+1];
    a[0]=0;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        b[i]=a[i]-a[i-1];
    }
    while(m--){
        int l,r,c;
        cin>>l>>r>>c;
        b[l]+=c;
        b[r+1]-=c;
    }
    for(int i=2;i<=n;i++){
        b[i]+=b[i-1];
    }
    for(int i=1;i<=n;i++){
        cout<<b[i]<<' ';
    }
}

```





# leetcode hot100

## 哈希表

### 128 最长连续序列

>   自己的思路，用set的

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        set<int> all;
        int max =0;
        for(int & num : nums){
            all.insert(num);
        }
        for(auto it = nums.begin();it!=nums.end();it++){
            int temp = 1;
            int n = *it+1;
            while(all.find(n)!=all.end()) {
                temp+=1;
                n++;
                it++;
            }
            if(max<temp){
                max = temp;
            }
        }
        return max;
    }
};
```

 官方题解：

差别，如果对当前num，存在num-1，跳过，因为上一步已经遍历过了

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> num_set;
        for (const int& num : nums) {
            num_set.insert(num);
        }

        int longestStreak = 0;

        for (const int& num : num_set) {
            if (!num_set.count(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;

                while (num_set.count(currentNum + 1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }

                longestStreak = max(longestStreak, currentStreak);
            }
        }

        return longestStreak;           
    }
};

```

## 滑动窗口

### 209 [长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

自己方法：前缀和加双指针

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
#include <vector>
#include <string>
#include <set>
using namespace std;

class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        //先写前缀和
        int s[nums.size()+1];
        s[0]=0;
        for(int i=0;i<nums.size();i++){
            s[i+1]=s[i]+nums[i];
        }
        //双指针
        int l=0,r=0;
        int min=nums.size();
        while(r<nums.size()){
            while(s[r]-s[l]<target && r<nums.size()) r++;
            while(s[r]-s[l]>target && r<nums.size()) l++;
            if(min>r-l && s[r]-s[l]==target) {
                min=r-l;
                r++;
            }
        }
        while(l<nums.size() && s[r]-s[l]>target){
            l++;
        }
        if(min>r-l && s[r]-s[l]==target) min=r-l;
        return min;
    }
};

int main(){
   int target =7;
   vector <int> nums;
   int a[]={2,3,1,2,4,3};
   nums.insert(nums.begin(),a,a+6);
   Solution s;
   int min;
   min=s.minSubArrayLen(target,nums);
   cout<<min<<endl;
}
```

题解：

```
'''
    滑动窗口
    l和r左右指针维护一个窗口，初始时均指向0, s=0代表[l, r]这个窗口的和
    while r < len(nums):
        # 求和
        s += nums[r]
        # while s >= target, 更新答案，且缩小窗口，即s-=nums[l], l+=1
        扩充窗口，即r+=1

    返回最终答案
    时间复杂度O(n), n=len(nums)
    空间复杂度O(1), 若干中间变量
    '''
```

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int m = nums.size();
        int i = 0, sum = 0, res = INT_MAX;
        for(int j = 0; j < m; j++){
            sum += nums[j];
            while(sum >= target){
                res = min(j - i + 1, res);
                sum -= nums[i];
                i++;
            }
        }
        return res < INT_MAX ? res : 0;
    }
};
```

### 3.无重复字符的最长子串

==有边界问题==

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
#include <vector>
#include <string>
#include <set>
using namespace std;

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int e[26]={0}; //用来存放当前窗口中存在的字符
        int res = 0; //最终结果
        int l=0,r=0; //左右指针，窗口的两边
        //如果当前窗口中没有重复的字符，r++，else，l++
        if(!s.length()) return 0;
        while(r<s.length()){
            if(s[r]-'a'>26 || s[r]-'a'<0){
                r++;
                res = max(res, r - l);
            }
            else {
                while (e[int(s[r] - 'a')] && l < r) {
                    res = max(res, r - l);
                    l++;
                }
                e[int(s[r] - 'a')] = 1;
                r++;
            }
        }

        return res;
    }
};

int main(){
    string a=" ";
    Solution s;
    cout<<s.lengthOfLongestSubstring(a)<<endl;
}
```

正确答案：

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        set<char> lookup;
        int l=0,r=0;
        int res=0;
        while(r<s.length()){
            while(lookup.find(s[r])!=lookup.end()){
                lookup.erase(s[l]);
                l++;
            }
            res = max(res,r-l+1);
            lookup.insert(s[r]);
            r++;
        }
        return res;
    }
};
```

###[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
#include <vector>
#include <string>
#include <set>
#include <unordered_set>
#include <array>
using namespace std;

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> res;
        array <int,26> cnt_p{};
        array<int, 26> cnt_s{};;
        for(char s:p){
            cnt_p[s-'a']+=1;
        }
        int l=0;
        for(int r=0;r<s.length();r++){
            cnt_s[s[r]-'a']+=1; //右端进入窗口
            if(r<p.length()-1) continue;
            if(cnt_p==cnt_s){
                res.push_back(r-p.length()+1);
            }
            cnt_s[s[r-p.length()+1]-'a']--;
        }
        return res;
    }
};

int main(){
    string s="cbaebabacd";
    string p="abc";
    Solution f;
    f.findAnagrams(s,p);
    
}
```

方法二，动态窗口，静态窗口是使两个数组相同，动态窗口是使最终的长度相同时两字符串相同

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> ans;
        int cnt[26]{}; // 统计 p 的每种字母的出现次数
        for (char c : p) {
            cnt[c - 'a']++;
        }
        int left = 0;
        for (int right = 0; right < s.size(); right++) {
            int c = s[right] - 'a';
            cnt[c]--; // 右端点字母进入窗口
            while (cnt[c] < 0) { // 字母 c 太多了
                cnt[s[left] - 'a']++; // 左端点字母离开窗口
                left++; 
            }
            if (right - left + 1 == p.length()) { // s' 和 p 的每种字母的出现次数都相同
                ans.push_back(left); // s' 左端点下标加入答案
            }
        }
        return ans;
    }
};

作者：灵茶山艾府
链接：https://leetcode.cn/problems/find-all-anagrams-in-a-string/solutions/2969498/liang-chong-fang-fa-ding-chang-hua-chuan-14pd/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



##子串

### [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

有坑，子数组并不是全为正数，所以不能使用双指针，需要使用哈希表进行优化

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
#include <vector>
#include <string>
#include <set>
#include <unordered_set>
#include <array>
#include <unordered_map>
using namespace std;
//前缀和加双指针
//有负数，双指针不行，因为前缀和不是递增的
//用哈希表优化，记录前缀和的值和出现的次数
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int s[nums.size()+1];
        s[0] = 0;
        int res;
        for(int i=0;i<nums.size();i++){
            s[i+1] = s[i] + nums[i];
        }
        unordered_map<int,int> map; //key是前缀和值，通过count计算前缀和出现的次数
        for(int a:s){
            //这里一边插入一边查找，可以只找用于找到左侧已经存在的前缀和，避免重复
            res+=map.count(a-k);
            map.insert(make_pair(a,1));
        }
        return res;
    }
};


int main(){
    int a[3]={1,1,1};
    vector<int> nums;
    nums.insert(nums.begin(),a,a+3);
    Solution s;
    cout<<s.subarraySum(nums,2);
}
```



##普通数组

### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

前缀和解，有问题，只适用最小值在最大值左侧的情况

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if(nums.size()==1){
            return nums[0];
        }
        int s[nums.size()+1];
        s[0] = 0;
        int max = -10000;
        int min = 10000;
        for(int i=0;i<nums.size();i++){
            s[i+1] = s[i] + nums[i];
            if(s[i+1]>max) max = s[i+1];
            if(s[i+1]<min) min = s[i+1];
        }
        if(min>=0) return max;
        else return max-min;
    }
};
```

标准题解：

动态规划解法

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int pre = 0; //前一个值的最大连续子数组和,从0开始
        int res = nums[0]; //整体最大值，随机初始
        for(int n:nums){
            pre = max(n,pre+n);
            res = max(pre,res);
        }
        return res;
    }
};

```

前缀和方法，想的不同，这里维护的是当前前缀和的最小值，而不是全局最小值

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int ans = INT_MIN;
        int min_pre_sum = 0;
        int pre_sum = 0;
        for (int x : nums) {
            pre_sum += x; // 当前的前缀和
            ans = max(ans, pre_sum - min_pre_sum); // 减去前缀和的最小值
            min_pre_sum = min(min_pre_sum, pre_sum); // 维护前缀和的最小值
        }
        return ans;
    }
};

作者：灵茶山艾府
链接：https://leetcode.cn/problems/maximum-subarray/solutions/2533977/qian-zhui-he-zuo-fa-ben-zhi-shi-mai-mai-abu71/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
    
    
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int s[nums.size()+1];
        int presum=0,minpresum=0;//presum 当前前缀和，minpresum 当前前缀和之前的最小值
        int ans=nums[0];
        for(int i=0;i<nums.size();i++){
            presum+=nums[i];
            ans = max(ans,presum-minpresum);
            minpresum = min(presum,minpresum);
        }
        return ans;
    }
};
```

### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

如果能在答案上直接操作就直接操作，不要中间商赚差价，会有边界问题

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
#include <vector>
#include <string>
#include <set>
#include <unordered_set>
#include <array>
#include<map>
#include <unordered_map>
using namespace std;
//对于二维向量的排序，sort默认为按第一列升序，如果需要自定义排序，可以用仿函数重载()运算符
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if(intervals.empty()) return{};
        sort(intervals.begin(),intervals.end());
        vector<vector<int>> res;
        int l=-1,r=0;
        res.push_back(intervals[0]);
        //这里的边界条件有点东西，当超出范围，直接将下一个压入res中，如果后面还有就继续判断，没有就返回
        for(int i=0;i<intervals.size();i++){
            if(intervals[i][0]<=res[res.size()-1][1]) res[res.size()-1][1]=max(res[res.size()-1][1],intervals[i][1]);
            else{
                res.push_back(intervals[i]);
            }
        }
        return res;
    }
};


int main(){
    vector<vector<int>> intervals;
    intervals.push_back({1,3});
    intervals.push_back({2,6});
    intervals.push_back({8,10});
    intervals.push_back({15,18});

    Solution s;
    s.merge(intervals);
}
```





### [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

超时了，注意insert的使用

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        for(int i=0;i<k;i++){
            int temp = nums.back();
            nums.pop_back();
            //在vector头部insert的时间复杂度是O(n)的，因为会使所有元素后移一位
            nums.insert(nums.begin(),temp);
        }
    }
};

```

题解：

空间换时间

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> newArr(n);
        for (int i = 0; i < n; ++i) {
            newArr[(i + k) % n] = nums[i];
        }
        nums.assign(newArr.begin(), newArr.end());
    }
};

```



### [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

前缀积&后缀积

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int front_mul[nums.size()+1];
        int back_mul[nums.size()+1];
        front_mul[0]=1;
        back_mul[0]=1;
        vector<int> res;
        for(int i=0;i<nums.size();i++){
            front_mul[i+1] = front_mul[i]*nums[i];
            res.push_back(front_mul[i]);
        }
        for(int i=nums.size();i>0;i--){
            back_mul[nums.size()-i+1] = back_mul[nums.size()-i] * nums[i-1];
            res[i-1]*=back_mul[nums.size()-i];
        }
        return res;
    }
};
```



##矩阵

###[73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

思路:用第一行和第一列记录本行或本列中需不需要置零

空间复杂度O1

还可以开辟两个数组，一个记录行为0的点，一个记录列为0的点，空间复杂度Omn，但不用单独判断第0行和第0列

```cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m=matrix.size(),n=matrix[0].size();
        int col_0=0,row_0=0;
        //单独判断第0行，第0列
        for(int i=0;i<m;i++){
            if(!matrix[i][0]) col_0 = 1;
        }
        for(int j=0;j<n;j++){
            if(!matrix[0][j]) row_0 = 1;
        }
        //遍历
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                if(!matrix[i][j]) matrix[0][j]=matrix[i][0]=0;
            }
        }
        //遍历置零
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                if(!matrix[0][j] || !matrix[i][0]) matrix[i][j]=0;
            }
        }
        //对于第一行和第一列单独处理
        if(row_0){
            for(int j=0;j<n;j++){
                matrix[0][j]=0;
            }
        }
        if(col_0){
            for(int i=0;i<m;i++){
                matrix[i][0] = 0;
            }
        }
    }
};
```



### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

有边界问题，在测试用例25，10*10的矩阵出问题了

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int directions[4][2] = {{0,1},{1,0},{0,-1},{-1,0}}; //右，下，左，上
        int step[4];
        if(matrix.size()==0)return {};
        //初始化，第一轮中的步数
        step[0]=matrix[0].size()-1;
        step[1]=matrix.size()-1;
        step[2]=matrix[0].size()-1;
        step[3]=matrix.size()-2;

        int rows = matrix.size(),cols=matrix[0].size();
        int total = matrix.size()*matrix[0].size();
        vector<int> res(total); //初始化为0

        int row=0,col=0; //当前行列
        int direction_idx = 0; //当前前进方向
        int s=step[direction_idx];
        for(int i=0;i<total;i++){
            res[i]=matrix[row][col];
            if(!s){
                if(direction_idx==0) step[direction_idx]-=1;
                else step[direction_idx]-=2;
                direction_idx = (direction_idx + 1)%4;
                s=step[direction_idx];
            }
            row += directions[direction_idx][0];
            col += directions[direction_idx][1];
            s-=1;
        }
        return res;
    }
};
```

题解：

```cpp
class Solution {
private:
    static constexpr int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0) {
            return {};
        }
        
        int rows = matrix.size(), columns = matrix[0].size();
        vector<vector<bool>> visited(rows, vector<bool>(columns));
        int total = rows * columns;
        vector<int> order(total);

        int row = 0, column = 0;
        int directionIndex = 0;
        for (int i = 0; i < total; i++) {
            order[i] = matrix[row][column];
            visited[row][column] = true;
            int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];
            if (nextRow < 0 || nextRow >= rows || nextColumn < 0 || nextColumn >= columns || visited[nextRow][nextColumn]) {
                directionIndex = (directionIndex + 1) % 4;
            }
            row += directions[directionIndex][0];
            column += directions[directionIndex][1];
        }
        return order;
    }
};

作者：力扣官方题解
链接：https://leetcode.cn/problems/spiral-matrix/solutions/275393/luo-xuan-ju-zhen-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## 链表

###[160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

法1：双指针

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(headA==nullptr || headB==nullptr) return nullptr;
        ListNode *pa = headA;
        ListNode *pb = headB;
        int timea=0,timeb=0;
        while(pa!=pb){
            pa = pa->next;
            pb = pb->next;
            if(pa == nullptr ) pa=headB , timea++;
            if(pb == nullptr ) pb=headA, timeb++;
            if(timea==2 || timeb==2) return nullptr;
        }
        return pa;
    }
};
```

法二：哈希表(简单但是复杂度高)



### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

法1：迭代/双指针

维护三个指针，一个指向前一个，一个指向现在，一个指向下一个(临时)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        //需要3个指针，当前节点，前一个，后一个
        ListNode *prev = nullptr;
        ListNode *curr = head;
        while(curr){
            //记录当前的下一个
            ListNode *next = curr->next;
            //当前的下一个指向前一个
            curr->next=prev;
            //前一个指向现在
            prev = curr;
            //向后移动
            curr = next;
        }
        return prev;
    }
};
```

### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

新建一个数组，存进去，一个个对比

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        vector<int> r;
        ListNode *p=head;
        while(p){
            r.push_back(p->val);
            p=p->next;
        }
        for(int i=0;i<r.size()/2;i++){
            if(r[i]!=r[r.size()-1-i]) return false;
        }
        return true;
    }
};
```



###[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

哈希，时间和空间复杂度都很高



```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        set<ListNode *> s;
        ListNode *p=head;
        while(p){
            if(s.find(p)!=s.end()){
                return true;
            }
            s.insert(p);
            p = p->next;
        }
        return false;
    }
};
```

快慢指针，时间On，空间O1

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* slow=head;
        ListNode* fast=head;
         while(fast&&fast->next)
         {  
            slow=slow->next;
            fast=fast->next->next;
            if(slow==fast)
            {
                return true;
            }  
         }
         return false;
    }
};
```





### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

快慢指针，找规律，在快慢指针相遇时，再使一个指针p指向head，p和s会在入环点相遇

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *f = head;
        ListNode *s = head;
        while(f && f->next){
            s = s->next;
            f = f->next->next;
            if(f==s) break;
        }
        if(!f || !f->next) return nullptr;
        ListNode *p = head;
        while(p!=s){
            p = p->next;
            s = s->next;
        }
        return p;
    }
};
```



### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

迭代

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode *l1 = list1;
        ListNode *l2 = list2;
        ListNode *head=new ListNode(-1);
        ListNode *p = head;
        while(l1 && l2){
            if(l1->val >= l2 -> val){
                p->next = l2;
                l2 = l2->next;
            }
            else{
                p->next = l1;
                l1 = l1->next;
            }
            p=p->next;
        }
        if(l1){
            p->next = l1;
        }
        if(l2){
            p->next = l2;
        }
        return head->next;
    }
};
```

递归

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (l1 == nullptr) {
            return l2;
        } else if (l2 == nullptr) {
            return l1;
        } else if (l1->val < l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        } else {
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }
};

作者：力扣官方题解
链接：https://leetcode.cn/problems/merge-two-sorted-lists/solutions/226408/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```





### [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

模拟

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int e = 0;
        ListNode *head = new ListNode(-1);
        ListNode *p = head;
        while(l1 || l2){
            int n1 = l1 ? l1->val:0;
            int n2 = l2 ? l2->val:0;
            int t = (n1 + n2+ e) %10;
            p->next = new ListNode(t);
            e = (n1 + n2 + e)/10;
            if(l1) l1 = l1->next;
            if(l2) l2 = l2->next;
            p = p->next;
        }
        if(e){
            p->next = new ListNode(e);
        }
        return head->next;
    }
};
```





###[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)



```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        int all=0;
        ListNode *p=head;
        ListNode *dummy = new ListNode (0,head); //哑巴节点，值为0，next为head
        while(p){
            all+=1;
            p=p->next;
        }   
        ListNode *cur = dummy;
        for(int i=0;i<all-n;i++){
            cur = cur->next;
        }
        cur->next = cur->next->next;
        return dummy->next;
    }
};
```





### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

思路：维护3个指针，一个指向上一次交换结束的末尾，一个指向next，一个指向next的next，交换后面的两个节点，后移

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode *dummy = new ListNode(0,head);
        ListNode *t =dummy;
        while(t->next != nullptr && t->next->next != nullptr){
            ListNode *n1 = t->next;
            ListNode *n2 = t->next->next;
            t->next = n1->next;
            n1->next = n2->next;
            n2->next = n1;
            t=n1;
        }
        return dummy->next;
        
    }
};
```



### [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

思路：用三遍遍历，第一遍将新节点加到老节点之后，第二遍处理random，第三遍分离

```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (head == nullptr) {
            return nullptr;
        }
        for (Node* node = head; node != nullptr; node = node->next->next) {
            Node* nodeNew = new Node(node->val);
            nodeNew->next = node->next;
            node->next = nodeNew;
        }
        for (Node* node = head; node != nullptr; node = node->next->next) {
            Node* nodeNew = node->next;
            nodeNew->random = (node->random != nullptr) ? node->random->next : nullptr;
        }
        Node* headNew = head->next;
        for (Node* node = head; node != nullptr; node = node->next) {
            Node* nodeNew = node->next;
            node->next = node->next->next;
            nodeNew->next = (nodeNew->next != nullptr) ? nodeNew->next->next : nullptr;
        }
        return headNew;
    }
};

作者：力扣官方题解
链接：https://leetcode.cn/problems/copy-list-with-random-pointer/solutions/889166/fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao-rblsf/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;

    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (!head){
            return NULL;
        }
        Node *p = head;
        //第一遍遍历，将所有新节点加到旧节点后面
        while(p){
            Node *temp = new Node(p->val);
            temp->next = p->next;
            p->next = temp;
            p = p->next->next;
        }

        //第二遍遍历，处理random
        p = head;
        while(p){
            if(p->random!=NULL){
                p->next->random = p->random->next;
            }
            p = p->next->next;
        }
        
        //第三遍，分离
        p = head;
        Node * newhead = p->next;
        while(p != NULL){
            Node * temp = p->next;
            p->next = temp->next;
            if(temp->next != NULL){
                temp->next = temp->next->next;
            }
            p = p->next;
        }

        return newhead;
    }
};
```









### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

==据说是重点== ，可以额外看看，重点是自主实现双向链表，并使用哈希表维护key和ptr

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include<map>
#include<string>
using namespace std;



//构建双向链表
struct DList{
    int key,value;
    DList *next;
    DList *prev;

    DList(): key(0),value(0),next(nullptr),prev(nullptr){};
    DList(int k,int v):key(k),value(v),next(nullptr),prev(nullptr){};
};


class LRUCache {
private:
    //用map存key和对应的ptr，实现快速查找
    unordered_map<int,DList *> map;
    //伪头节点，尾结点
    DList * head;
    DList * tail;
    //当前size和容量大小
    int s;
    int c;

public:
    LRUCache(int capacity) {
        c = capacity;
        s = 0;
        head = new DList();
        tail = new DList();
        //初始头尾相连
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int key) {
        if(map.find(key)!=map.end()){
            move2head(map[key]);
            return map[key]->value;
        }
        else{
            return -1;
        }
        
    }
    
    void put(int key, int value) {
        if(map.find(key)==map.end()){
            DList * p = new DList(key,value);
            map.insert(make_pair(key,p));
            add2head(p);
            s+=1;
            if(s>c){
                //超出范围，删除最后一个
                DList * remove = removeTail();
                //删除map中对应的项
                map.erase(remove->key);
                delete remove;
                s--;
            }
        }
        else{
            DList* node = map[key];
            node->value = value;
            move2head(node);
        }

        
    }
    //添加到头部
    void add2head(DList * node){
        node->next = head->next;
        node->prev = head;
        head->next->prev = node;
        head->next = node;
    }
    //移除节点
    void removenode(DList * node){
        node->next->prev = node->prev;
        node->prev->next = node->next;
    }
    //移动至头部
    void move2head(DList * node){
        removenode(node);
        add2head(node);
    }
    //移除尾部并返回,需要返回的原因是同时需要删除map中对应的key
    DList* removeTail(){
        DList * temp = tail->prev;
        removenode(temp);
        return temp;
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */

```

## 二叉树

### [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

深度优先遍历的核心，分清三步

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //首先确定传入的参数和返回值（根节点和结果数组）
    void traversal(TreeNode * mid, vector<int> &res){
        //终止条件，当遍历到最底下，返回
        if(mid == nullptr) return;
        //当前操作，将中间的val加入数组
        res.push_back(mid->val);
        //到下一层的逻辑，先遍历左边，再遍历右边
        traversal(mid->left,res);
        traversal(mid->right,res);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        traversal(root,res);
        return res;
    }
};
```



###[94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void traversal(TreeNode *cur,vector<int> &res){
        if(cur == nullptr) return;
        
        //前中后序遍历的区别，先遍历还是先push_back
        traversal(cur->left,res);
        res.push_back(cur->val);
        traversal(cur->right,res);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        traversal(root,res);
        return res;
    }
};
```



###[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

前序遍历求最深

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int res = 0;
    void getdeep(TreeNode* cur,int d){
        if(cur==nullptr){
            res = max(res,d);
            return;
        }
        d+=1; //这里的d是每个节点独有的，在返回时会变成上一层的d
        getdeep(cur->left,d);
        getdeep(cur->right,d);
    }

    int maxDepth(TreeNode* root) {
        getdeep(root,0);
        return res;
    }
};
```

后序遍历求树的高度

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int getdeep(TreeNode* cur){
        if(cur==nullptr){
            return 0 ;
        }
        //后序遍历
        int l = getdeep(cur->left);
        int r = getdeep(cur->right);
        return 1+max(l,r);
    }

    int maxDepth(TreeNode* root) {
        int res = getdeep(root);
        return res;
    }
};
```

### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

核心是确定遍历顺序

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        //前序遍历
        if(root == nullptr) return root;
        swap(root->left,root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};


//同理，后序遍历同样可行，忘了就画图
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr) return root;
        invertTree(root->left);
        invertTree(root->right);
        swap(root->left,root->right);
        return root;
    }
};
```







### [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)



```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    queue<TreeNode*> que;
    int size;
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == nullptr) return res;
        que.push(root);
        size++;
        while(!que.empty()){
            vector<int> vec;
            int s = 0;
            while(size--){
                //先弹出
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if(node->left != nullptr){
                    que.push(node->left);
                    s++;
                }
                if(node->right != nullptr){
                    que.push(node->right);
                    s++;
                }
            }
            size = s;
            res.push_back(vec);
        }
        return res;
    }
};
```





### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

后序遍历，有点不一样，先两边，再中间

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool compare(TreeNode* left,TreeNode* right){
        if(left == nullptr && right != nullptr) return false;
        if(left != nullptr && right == nullptr) return false;
        if(left == nullptr && right == nullptr) return true;
        if(left->val != right->val) return false;
        bool l = compare(left->left,right->right);
        bool r = compare(left->right,right->left);
        return l&&r;
    }
    bool isSymmetric(TreeNode* root) {
        return compare(root->left,root->right);
    }
};
```





### [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

==二叉树的核心就是判断用那种遍历方法==

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int res = 0;
    //求高度，后序
    int getheight(TreeNode* root){
        if(root == nullptr) return 0;
        int l = getheight(root->left);
        int r = getheight(root->right);
        //==在每一个中心节点判断一次左右最深的节点的距离==
        res = max(res,l+r);
        int h = 1+max(l,r);
        return h;
    }
    int diameterOfBinaryTree(TreeNode* root) {
        getheight(root);
        return res;
    }
};
```





### [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)



```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* sort(vector<int>& nums,int l,int r){
        if(l>r) return nullptr;
        int mid = (l+r)/2; // 偏左
        TreeNode* cur = new TreeNode(nums[mid]);
        cur->left = sort(nums,l,mid-1);
        cur->right = sort(nums,mid+1,r);
        return cur;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if(nums.size() == 0) return nullptr;
        return sort(nums,0,nums.size()-1);
    }
};
```

### [230. 二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

中序遍历

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long min = LONG_MIN;
    int num;
    void midsearch(TreeNode* root){
        if(root == nullptr) return;
        midsearch(root->left);
        if(!--num){
            min = root->val;
            return;
        }
        midsearch(root->right);
    }
    //中序遍历
    int kthSmallest(TreeNode* root, int k) {
        num = k;
        midsearch(root);
        return min;
    }
};
```





### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

法一：广度遍历，耗时长，空间小

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //广度遍历，将所有最后的size返回
    queue<TreeNode*> que;
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        int size = 0;
        que.push(root);
        size++;
        while(que.size()){
            int s = 0;
            //遍历每一层
            while(size--){
                //先弹出
                TreeNode* node = que.front();
                que.pop();
                if(size == 0) res.push_back(node->val);
                if(node->left != nullptr){
                    que.push(node->left);
                    s++;
                }
                if(node->right != nullptr){
                    que.push(node->right);
                    s++;
                }
            }
            size = s;
        }
        return res;
    }
};
```



### [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

逻辑优点怪，多看看

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* root) {
        TreeNode* cur = root;
        while(cur){
            if(cur->left != nullptr){
                //找到左节点的最右节点
                TreeNode* p = cur->left;
                while(p->right) p = p->right;
                p->right = cur->right;
                cur->right = cur->left;
                cur->left = nullptr;
            }
            cur = cur->right;
        }
    }
};
```



### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long max = LONG_MIN;
    bool isValidBST(TreeNode* root) {
        //中序遍历
        if(root == nullptr) return true;
        bool l = isValidBST(root->left);
        if(max < root->val){
            max = root->val;
        }
        else return false;
        bool r = isValidBST(root->right);
        return l&&r;
    }
};
```



### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr) return nullptr;
        if(root == p || root == q) return root;
        TreeNode* l = lowestCommonAncestor(root->left,p,q);
        TreeNode* r = lowestCommonAncestor(root->right,p,q);
        
        if(l == nullptr && r != nullptr) return r;
        if(l != nullptr && r == nullptr) return l;
        if(l != nullptr && r!= nullptr) return root;
        else return nullptr;
    }
};
```





### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

双递归

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //双递归
    int pathSum(TreeNode* root, long targetSum) {
        if(root == nullptr) return 0;
        int res = 0;
        res += rootsum(root,targetSum);
        res += pathSum(root->left,targetSum);
        res += pathSum(root->right,targetSum);
        return res;
    }

    //第一个递归，计算从当前节点开始左右节点中有没有相加等于target的路径
    int rootsum(TreeNode* cur,long targetSum){
        int resi = 0;
        if(cur == nullptr) return 0;
        targetSum -= cur->val;
        if(targetSum ==  0) resi+=1;
        resi += rootsum(cur->left,targetSum);
        resi += rootsum(cur->right,targetSum);
        return resi;
    }
};
```

## 图论

### [797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/)

在中间for遍历的地方还需要练

```cpp
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    //x是当前点的位置信息，n是要找点的位置信息
    void dfs(vector<vector<int>>& graph,int x,int n){
        if(x == n){
            res.push_back(path);
            return;
        }
        //遍历每一个节点所连接的节点
        //y是当前节点所连接节点的编号
        for(auto &y:graph[x]){
            path.push_back(y);
            dfs(graph,y,n);
            path.pop_back();
        }
    }
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        path.push_back(0);
        dfs(graph,0,graph.size()-1);
        return res;
    }
};
```



### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

需要复习

```cpp
class Solution {
public:
    int dirc[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
    void dfs(vector<vector<char>>& grid,int x,int y){
        for(int i=0;i<4;i++){
            int n_x = x+dirc[i][0];
            int n_y = y+dirc[i][1];
            if(n_x>=grid.size() || n_x <0 || n_y>=grid[0].size() || n_y<0) continue;
            if(grid[n_x][n_y] == '1') {
                grid[n_x][n_y] = '2';
                dfs(grid,n_x,n_y);
            }
        } 
    }
    int numIslands(vector<vector<char>>& grid) {
        int res = 0;
        for(int i=0;i<grid.size();i++){
            for(int j=0;j<grid[0].size();j++){
                if(grid[i][j]=='1'){
                    grid[i][j] = '2';
                    res+=1;
                    dfs(grid,i,j);
                }
            }
        }
        return res;
    }
};
```



## 回溯

### [77. 组合](https://leetcode.cn/problems/combinations/)

常看常新

```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(int idx,int n,int k){
        if(path.size()==k){
            res.push_back(path);
            return;
        }
        for(int i = idx;i<=n;i++){
            path.push_back(i);
            backtracking(i+1,n,k);
            path.pop_back();
        }
    }
    vector<vector<int>> combine(int n, int k) {
        backtracking(1,n,k);
        return res;
    }
};
```

